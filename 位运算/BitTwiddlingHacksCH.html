位操作技巧
作者：肖恩·埃伦·安德森 seander@cs.stanford.edu
单独来看， 这里的代码片段属于公共领域 （除非另有说明）——请随意使用它们。 汇总收集和描述如下 © 1997-2005 肖恩·埃伦·安德森。 代码和说明已分发 希望它们能够有用， 但不提供任何担保 ，甚至不提供任何关于适销性或特定用途适用性的默示担保。截至 2005 年 5 月 5 日，所有代码均已彻底测试。数千人已阅读过。此外，卡内基梅隆大学计算机科学系主任兰德尔·布莱恩特教授亲自使用他的 UClid 代码验证系统测试了几乎所有内容。他未测试的部分，我已与所有 32 位机器上可能的输入。 对于第一个向我报告代码中合法 bug 的人，我将支付 10 美元的赏金（通过支票或 PayPal 支付） 。如果捐赠给慈善机构，我将支付 20 美元。


关于操作计数方法
当计算此处算法的运算次数时， 任何 C 运算符都算作一次运算。 中间任务不需要写入 RAM， 不算数。 当然，这种操作计数方法仅作为 实际机器指令数和 CPU 时间的近似值。 假设所有操作都花费相同的时间， 事实并非如此，但 CPU 在这方面的表现越来越好 随着时间的推移，方向会发生变化。有很多细微的差别决定了 系统运行给定代码样本的速度有多快，例如缓存大小， 内存带宽、指令集等。最后，基准测试是 确定一种方法是否真的比另一种方法更快的最佳方法， 因此，请考虑以下技术作为测试目标的可能性 建筑学。

计算整数的符号
int v; // 我们想找到 v 的符号
int sign; // 结果放在这里 // CHAR_BIT 是每字节的位数（通常为 8）。
符号 = -(v < 0); // 如果 v < 0 则为 -1，否则为 0。
// 或者，为了避免在带有标志寄存器的 CPU 上分支（IA32）：
符号 = - (int)((unsigned int)((int)v) >> (sizeof(int) * CHAR_BIT - 1));
// 或者，少一条指令（但不可移植）：
符号 = v >> (sizeof(int) * CHAR_BIT - 1);
上面最后一个表达式的计算结果为 sign = v >> 31 针对 32 位整数。 这是一个比显而易见的方法 sign = -(v < 0) 更快的操作。 这个技巧之所以有效，是因为当有符号整数向右移动时，值 最左边的位被复制到其他位。最左边的位为 1 当值为负数时为 0，否则为 0；所有 1 位均表示 -1。 不幸的是，这种行为是特定于体系结构的。
或者，如果您希望结果是 -1 或 +1，则使用：

符号 = +1 | (v >> (sizeof(int) * CHAR_BIT - 1)); // 如果 v < 为 0 则为 -1，否则为 +1
另一方面，如果您希望结果是 -1、0 或 +1，则使用：

符号 = (v != 0) | -(int)((unsigned int)((int)v) >> (sizeof(int) * CHAR_BIT - 1));
// 或者，为了获得更快的速度但降低可移植性：
符号 = (v != 0) | (v >> (sizeof(int) * CHAR_BIT - 1)); // -1、0 或 +1
// 或者，为了可移植性、简洁性和（也许）速度：
符号 = (v > 0) - (v < 0)； // -1、0 或 +1
如果你想知道某个东西是否是非负数，结果是 +1 或 否则为 0，然后使用：
sign = 1 ^ ((unsigned int)v >> (sizeof(int) * CHAR_BIT - 1)); // 如果 v < 0 则为 0，否则为 1
警告：2003 年 3 月 7 日，Angus Duggan 指出 1989 ANSI C 规范保留有符号右移实现定义的结果， 所以在某些系统上这个 hack 可能不起作用。为了更好的可移植性， Toby Speight 于 2005 年 9 月 28 日建议在这里使用 CHAR_BIT 而不是假设字节长度为 8 位。Angus 建议 上述更便携的版本，涉及 2006 年 3 月 4 日的铸造。 Rohit Garg 建议的版本 表示 2009 年 9 月 12 日的非负整数。

检测两个整数是否具有相反的符号
int x, y; // 输入值来比较符号 bool f = ((x ^ y) < 0); // 当且仅当 x 和 y 符号相反时为真
2009 年 11 月 26 日，Manfred Weis 建议我添加此条目。

计算整数绝对值 (abs)，无需分支
int v; // 我们想找到 v 的绝对值
unsigned int r; // 结果放在这里
int const mask = v >> sizeof(int) * CHAR_BIT - 1;r = (v + mask) ^ mask;
专利变体：
r = (v^mask)-mask；
有些 CPU 没有整数绝对值指令（或 编译器无法使用它们）。在分支操作开销很大的机器上， 上述表达式比显而易见的方法更快， r = (v < 0) ? -(unsigned)v : v，即使操作次数 是一样的。
2003 年 3 月 7 日，Angus Duggan 指出 1989 ANSI C 规范保留有符号右移实现定义的结果， 所以在某些系统上，这个 hack 可能不起作用。我读到过 ANSI C 不允许 要求值以二进制补码表示，因此可能不起作用 出于这个原因（在越来越少的旧机器上 仍然使用补码）。 2004 年 3 月 14 日，Keith H. Duggar 给我发了上述专利变体；它是 比我最初想出的方案要好， r=(+1|(v>>(sizeof(int)*CHAR_BIT-1)))*v ，因为没有使用乘法。遗憾的是，该方法已于 2000 年 6 月 6 日由 Vladimir Yu Volkonsky 在美国申请专利 ，并已转让给 Sun Microsystems 公司 。 2006 年 8 月 13 日，Yuriy Kaminskiy 告诉我，这项专利很可能无效，因为该方法 在专利申请之前就已经公开，例如 如何优化奔腾处理器， 作者：Agner Fog，1996 年 11 月 9 日。Yuriy 也 提到该文件于 1997 年被翻译成俄文， 弗拉基米尔本可以读。此外，互联网档案馆还收藏了 链接到它。 2007 年 1 月 30 日，Peter Kankowski 与我分享了一个 abs 版本 他发现这是受到微软 Visual C++ 编译器输出的启发。 这里将其作为主要解决方案来介绍。 2007年12月6日，海进抱怨说，结果已经签了，所以当 计算最负值的绝对值，它仍然是负值。 2008 年 4 月 15 日，安德鲁·夏皮拉 (Andrew Shapira) 指出，显而易见的方法 可能会溢出，因为当时缺少（无符号）转换； 为了实现最大程度的便携性，他建议 (v < 0) ? (1 + ((unsigned)(-1-v))) : (unsigned)v 。但 Vincent Lefèvre 在 2008 年 7 月 9 日引用了 ISO C99 规范，说服我删除了它，因为即使在不支持二进制补码的机器上，-(unsigned)v 也能正确执行。对 -(unsigned)v 的求值首先会将 v 的负值加上 2**N 转换为无符号数，从而得到 v 值的二进制补码表示，我将其称为 U。然后，对 U 取反，得到所需的结果：-U = 0 - U = 2**N - U = 2**N - (v+2**N) = -v = abs(v)。


计算两个整数的最小值 (min) 或最大值 (max)，无需分支
int x; // 我们想要找到 x 和 y 中的最小值
int y;
int r; // 结果放在这里 r = y ^ ((x ^ y) & -(x < y)); // min(x, y)
在一些罕见的机器上，分支非常昂贵，并且没有条件 移动指令存在，上述表达式 可能比显而易见的方法更快，r = (x < y) ? x : y，甚至 尽管它涉及另外两个指令。 （不过，通常情况下，显而易见的方法是最好的。） 之所以有效，是因为如果 x < y， 那么 -(x < y) 将全部为 1， 所以 r = y ^ (x ^ y) & ~0 = y ^ x ^ y = x。 否则，如果 x >= y， 那么 -(x < y) 将全为零， 所以 r = y ^ ((x ^ y) & 0) = y。 在某些机器上，将 (x < y) 计算为 0 或 1 需要分支指令，因此可能没有 优势。
要找到最大值，请使用：

r = x ^ ((x ^ y) & -(x < y)); // 最大值(x, y)
快速而肮脏的版本：
如果你知道 INT_MIN <= x - y <= INT_MAX， 那么你可以使用下面的方法 速度更快，因为 (x - y) 只需要计算一次。
r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); // 最小值（x，y）
r = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); // 最大值(x, y)
请注意，1989 ANSI C 规范没有指定 有符号右移，因此这些是不可移植的。 如果溢出引发异常，则 x 的值 并且 y 应该是无符号的，或者在减法运算时转换为无符号的 为了避免不必要地抛出异常，右移 需要一个有符号的操作数来在负数时产生所有 1 位，因此 在那里签名。
2003 年 3 月 7 日，Angus Duggan 指出了右移可移植性问题。2005 年 5 月 3 日，Randal E. Bryant 提醒我需要前提条件 INT_MIN <= x - y <= INT_MAX，并建议使用非快速且不规范的版本进行修复。这两个问题都只与快速且不规范的版本有关。Nigel Horspoon 在 2005 年 7 月 6 日观察到，gcc 在奔腾处理器上生成的代码与显而易见的解决方案相同，因为它对 (x < y) 的求值方式不同。2008 年 7 月 9 日，Vincent Lefèvre 指出，在 r = y + ((x - y) & -(x < y))（这是之前的版本）中使用减法可能会出现溢出异常。2009 年 6 月 2 日，Timothy B. Terriberry 建议使用异或（xor）而不是加减法来避免强制类型转换和溢出风险。


确定整数是否为 2 的幂
unsigned int v; // 我们想看看 v 是否是 2 的幂
bool f; // 结果放在这里 f = (v & (v - 1)) == 0;
请注意，这里 0 被错误地认为是 2 的幂。为了补救 这样，使用：
f = v && !(v & (v - 1));
从恒定位宽扩展符号
对于内置类型（例如字符和整数），符号扩展是自动的。 但假设你有一个有符号的二进制补码数 x，它存储在 仅使用 b 位。此外，假设你想将 x 转换为 int， 其比特数超过 b。如果 x 为正数，但如果为负数，则符号必须扩展。例如， 如果我们只有 4 位来存储数字，那么 -3 表示为 1101 二进制。如果我们有 8 位，那么 -3 就是 11111101。最高有效位 4 位表示中的位被左复制以填充 在目标中，当我们转换为具有更多位的表示形式时； 这是符号延伸。 在 C 语言中，从恒定位宽进行符号扩展是很简单的事情，因为位 字段可以在结构或联合中指定。 例如，要从 5 位转换为完整整数：
int x; // 将其从使用 5 位转换为完整 int
int r; // 将结果符号扩展数字放在此处
结构{有符号整数 x：5；} s；
r=sx=x；
以下是使用相同 语言功能可以通过一次操作从 B 位进行转换（尽管 当然，编译器会生成更多）。
模板 <typename T，无符号 B>
内联 T 符号扩展（const T x）
{
结构{T x：B;} s;
返回 sx = x;
}int r = signextend<signed int,5>(x); // 将 5 位数 x 符号扩展为 r
2005 年 5 月 2 日，John Byrd 发现了代码中的拼写错误（归因于 html 格式）。2006 年 3 月 4 日，Pat Wood 指出 ANSI C 标准要求位字段必须具有关键字“signed”才能带符号；否则，符号未定义。

从可变位宽扩展符号
有时我们需要扩展数字的符号，但我们不知道先验 表示该数据的位数 b。（或者我们也可以 使用 Java 等缺少位域的语言进行编程。
unsigned b; // 表示 x 中数字的位数
int x; // 将此 b 位数字符号扩展为 r
int r; // 结果符号扩展数
int const m = 1U << (b - 1); // 如果 b 是固定的，则可以预先计算掩码 x = x & ((1U << b) - 1); // （如果 x 中位置 b 以上的位已经为零，则跳过此步骤。）
r=（x^m）-m；
上面的代码需要四个操作，但是当位宽为 常量而不是变量，它只需要两个快速操作， 假设高位已经为零。
一个稍微快一点但可移植性较差的方法是，它不依赖于 x 中位置 b 以上的位是否为零：

int const m = CHAR_BIT * sizeof(x) - b;
r = (x<< m)>> m;
Sean A. Irvine 建议我 2004 年 6 月 13 日将符号扩展方法添加到此页面，并提供 m = (1 << (b - 1)) - 1; r = -(x & ~m) | x; 作为起点，我进行了优化，得到 m = 1U << (b - 1); r = -(x & m) | x。但在 2007 年 5 月 11 日，Shay Green 提出了上述版本，该版本比我的版本少了一个操作。2008 年 10 月 15 日，Vipin Sharma 建议我添加一个步骤来处理 x 在除了我们想要进行符号扩展的 b 位之外的其他位上可能为 1 的情况。2009 年 12 月 31 日，Chris Pirazzi 建议我添加更快的版本，该版本对于恒定位宽需要两次操作，对于可变位宽需要三次操作。


通过 3 次运算从可变位宽进行符号扩展
由于需要付出努力，以下操作在某些机器上可能会很慢 乘法和除法。这个版本是4个运算。如果你 知道你的初始位宽 b 大于 1，你可以这样做 通过使用 3 种操作实现符号扩展类型 r = (x * 乘数[b]) / 乘数[b]， 只需要一次数组查找。
unsigned b; // 表示 x 中数字的位数
int x; // 将此 b 位数字符号扩展为 r
int r; // 结果符号扩展数
#define M(B) (1U << ((sizeof(x) * CHAR_BIT) - B)) // CHAR_BIT=位/字节
静态 int const 乘数[] =
{
0、M(1)、M(2)、M(3)、M(4)、M(5)、M(6)、M(7)、
中(8)、中(9)、中(10)、中(11)、中(12)、中(13)、中(14)、中(15)
男(16)、男(17)、男(18)、男(19)、男(20)、男(21)、男(22)、男(23)、
男(24)、男(25)、男(26)、男(27)、男(28)、男(29)、男(30)、男(31)、
男(32)
}; //（如果使用超过 64 位则添加更多）
静态 int const 除数[] =
{
1、~M(1)、M(2)、M(3)、M(4)、M(5)、M(6)、M(7)
中(8)、中(9)、中(10)、中(11)、中(12)、中(13)、中(14)、中(15)
男(16)、男(17)、男(18)、男(19)、男(20)、男(21)、男(22)、男(23)、
男(24)、男(25)、男(26)、男(27)、男(28)、男(29)、男(30)、男(31)、
男(32)
}; //（为 64 位添加更多）
#undef M
r = (x * 乘数[b]) / 除数[b];
以下变体不可移植， 但在采用算术右移的体系结构中， 维护标志，应该很快。
const int s = -b; // 或：sizeof(x) * CHAR_BIT - b;
r = (x<< s)>> s;
Randal E. Bryant 于 2005 年 5 月 3 日指出了早期版本中的一个错误 （使用乘数[]作为除数[]），但在以下情况下失败了 x=1 和 b=1。

有条件地设置或清除位而无需分支
bool f; //条件标志
unsigned int m; // 位掩码
unsigned int w; // 要修改的字：if (f) w |= m; else w &= ~m; w ^= (-f ^ w) & m;// OR，对于超标量 CPU：
w = (w & ~m) | (-f & m);
在某些架构中，缺乏分支可以弥补 看起来操作数量是原来的两倍。例如，非正式 在 AMD Athlon™ XP 2100+ 上进行的速度测试表明，其速度为 5-10% 更快。英特尔酷睿 2 双核处理器运行超标量版本的速度大约为 16% 比第一个更快。 Glenn Slayden 告诉我关于 2003 年 12 月 11 日，Marco Yu 与我分享了超标量版本 2007 年 4 月 3 日，并在 2 天后提醒我有一个打字错误。

有条件地否定一个值而不进行分支
如果只需要在标志为假时取反，则使用以下命令 避免分支：
bool fDontNegate; // 标志表明我们不应该否定 v。
int v; // 如果 fDontNegate 为假，则输入要取反的值。
int r; // 结果 = fDontNegate ? v : -v;r = (fDontNegate ^ (fDontNegate - 1)) * v;
如果仅当标志为真时才需要否定，则使用以下命令：
bool fNegate; // 标志指示我们是否应该否定 v。
int v; // 如果 fNegate 为真，则输入要取反的值。
int r; // 结果 = fNegate ? -v : v;r = (v ^ -fNegate) + fNegate;
2009 年 6 月 2 日，Avraham Plotnitzky 建议我添加第一个版本。 为了避免乘法，我想出了第二个版本 2009 年 6 月 8 日。阿方索·德·格雷戈里奥指出，一些父母 于 2009 年 11 月 26 日失踪，并获得了漏洞赏金。

根据掩码合并两个值的位
unsigned int a; //非屏蔽位中要合并的值
unsigned int b; // 合并掩码位的值
无符号整数掩码；//1 其中应选择来自 b 的位；0 其中应选择来自 a 的位。
unsigned int r; // (a & ~mask) | (b & mask) 的结果放在这里 = a ^ ((a ^ b) & mask);
这比组合两组比特的明显方法省去了一个操作 根据位掩码。如果掩码是常数，则可能没有 优势。
Ron Jeffery 于 2006 年 2 月 9 日将此发送给我。


计数位设置（简单的方法）
unsigned int v; // 计算 v 中设置的位数
unsigned int c; // c 累计 vfor 中设置的总位（c = 0; v; v >>= 1）
{
c += v & 1;
}
简单的方法需要每个比特进行一次迭代，直到不再 位被设置。因此，在一个只有高位被设置的 32 位字上， 它将经历 32 次迭代。

通过查找表计算设置的位
静态 const 无符号字符 BitsSetTable256[256] =
{
# 定义 B2(n) n, n+1, n+1, n+2
# 定义 B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)
# 定义 B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)
B6(0)、B6(1)、B6(1)、B6(2)
};unsigned int v; // 计算 32 位值 v 中设置的位数
unsigned int c; // c 是 v 中设置的总位数// 选项 1：
c = BitsSetTable256[v & 0xff] +
BitsSetTable256[(v >> 8) & 0xff] +
BitsSetTable256[(v >> 16) & 0xff] +
位设置表 256[v >> 24]; // 选项 2：
无符号字符*p = (无符号字符*)&v;
c = 位设置表 256[p[0]] +
位设置表 256[p[1]] +
位设置表 256[p[2]] +
位设置表 256[p[3]];
// 最初以算法方式生成表：
位设置表256[0] = 0;
对于（int i = 0；i < 256；i ++）
{
位设置表 256[i] = (i & 1) + 位设置表 256[i / 2];
}
2009 年 7 月 14 日，Hallvard Furuseth 提出了宏压缩表。


用 Brian Kernighan 的方法计算位设置
unsigned int v; // 计算 v 中设置的位数
unsigned int c; // c 累计 v 中设置的总位
对于（c = 0; v; c++）
{
v &= v - 1; // 清除最低有效位设置
}
Brian Kernighan 的方法经过多次迭代 因为有设置位。所以如果我们有一个 32 位字，只有 高位设置，那么它将只循环一次。
1988 年出版的《C 语言程序设计》第二版（作者：Brian W. Kernighan 和 Dennis M. Ritchie）在练习 2-9 中提到了这一点。2006 年 4 月 19 日，Don Knuth 向我指出，这种方法“最初由 Peter Wegner 在 CACM 3 (1960) 第 322 页发表。（Derrick Lehmer 也独立发现了这种方法，并于 1964 年发表在 Beckenbach 编辑的一本书中。）”


使用 64 位指令对 14、24 或 32 位字中的位进行计数
unsigned int v; // 计算 v 中设置的位数
unsigned int c; // c 累计 v 中设置的总位数// 选项 1，v 中最多有 14 位值：
c = (v * 0x200040008001ULL & 0x1111111111111111ULL) % 0xf;// 选项 2，v 中最多 24 位值：
c = ((v & 0xfff) * 0x1001001001001ULL & 0x84210842108421ULL) % 0x1f;
c += (((v & 0xfff000) >> 12) * 0x1001001001001ULL & 0x84210842108421ULL)
% 0x1f;// 选项 3，v 中最多 32 位值：
c = ((v & 0xfff) * 0x1001001001001ULL & 0x84210842108421ULL) % 0x1f;
c += (((v & 0xfff000) >> 12) * 0x1001001001001ULL & 0x84210842108421ULL) %
0x1f；
c += ((v>> 24) * 0x1001001001001ULL & 0x84210842108421ULL) % 0x1f;
此方法需要具有快速模数除法的 64 位 CPU 才能高效。 第一个选项仅需 3 次操作；第二个选项需要 10 次；并且 第三个选项需要 15。
Rich Schroeppel 最初创建了一个 9 位版本，类似于选项 1； 请参阅编程技巧部分 Beeler, M.、Gosper, RW 和 Schroeppel, R. HAKMEM。麻省理工学院人工智能备忘录 239，1972 年 2 月 29 日。 他的方法是 Sean Anderson 设计的上述变体的灵感来源。Randal E. Bryant 于 2005 年 5 月 3 日修复了一些错误。Bruce Dawson 于 2007 年 2 月 1 日对 12 位版本进行了调整，使其适用于 14 位，操作次数相同。



并行计数位设置
unsigned int v; // 计数此设置位（32 位值）
unsigned int c; // 在这里存储总数
static const int S[] = {1, 2, 4, 8, 16}; // 魔法二进制数
静态 const int B[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF};c = v - ((v >> 1) & B[0]);
c = ((c >> S[1]) & B[1]) + (c & B[1]);
c = ((c >> S[2]) + c) & B[2];
c = ((c >> S[3]) + c) & B[3];
c = ((c >> S[4]) + c) & B[4];
B 数组以二进制表示为：
B[0] = 0x55555555 = 01010101 01010101 01010101 01010101
B[1] = 0x33333333 = 00110011 00110011 00110011 00110011
B[2] = 0x0F0F0F0F = 00001111 00001111 00001111 00001111
B[3] = 0x00FF00FF = 00000000 11111111 00000000 11111111
B[4] = 0x0000FFFF = 00000000 00000000 11111111 11111111
我们可以通过继续以下方法调整方法以适应更大的整数大小 二进制幻数 B 和 S 的模式。 如果有 k 位，那么我们需要数组 S 和 B 为 ceil(lg(k)) 元素长度，并且我们必须计算与 c 相同数量的表达式 S 或 B 为长整型。对于 32 位 v，需要进行 16 次运算。
计算 32 位整数 v 中位数的最佳方法如下：

v = v - ((v >> 1) & 0x55555555); // 重新使用输入作为临时输入
v = (v & 0x33333333) + ((v >> 2) & 0x33333333); // 温度
c = ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; // 计数
最佳的位计数方法仅需 12 次操作，与查找表方法相同，但避免了查找表带来的内存占用和潜在的缓存未命中问题。它是上述纯并行方法与之前使用乘法的方法（详见使用 64 位指令计数位部分）的混合体，尽管它不使用 64 位指令。字节中设置的位计数是并行完成的，字节中设置的位总数通过乘以 0x1010101 并右移 24 位来计算。

对于位宽高达 128 的整数（由类型 T 参数化），最佳位计数方法的概括如下：

v = v - ((v >> 1) & (T)~(T)0/3); // 温度
v = (v & (T)~(T)0/15*3) + ((v >> 2) & (T)~(T)0/15*3); // 温度
v = (v + (v >> 4)) & (T)~(T)0/255*15; // 温度
c = (T)(v * ((T)~(T)0/255)) >> (sizeof(T) - 1) * CHAR_BIT; // 计数
有关计算设置的位数（也称为侧向加法 ）的更多信息，请参阅 Ian Ashdown 的精彩新闻组帖子 。2005 年 10 月 5 日， Andrew Shapira 向我介绍了最好的位计数方法； 他在 187-188 页找到了它 AMD Athlon™ 64 和 Opteron™ 处理器软件优化指南 。Charlie Gordon 于 2005 年 12 月 14 日提出了一种从纯并行版本中精简一项操作的方法，Don Clugston 于 2005 年 12 月 30 日又精简了三项操作。我错误地拼写了 Don 的建议，Eric Cole 于 2006 年 1 月 8 日发现了这一点。Eric 后来于 2006 年 11 月 17 日建议将任意位宽推广到最佳方法。2007 年 4 月 5 日，Al Williams 发现我在第一个方法的顶部有一行死代码。


从最高有效位到指定位置计数设置的位（等级）
下面的代码查找位的秩，这意味着它返回 从最高有效位到 给定的位置。
uint64_t v; // 计算 v 中从 MSB 到 pos 的排名（位设置）。
unsigned int pos; // 要计数的位数。
uint64_t r; // pos 位的结果等级放在此处。 // 在给定位置后移出位。
r = v >> (sizeof(v) * CHAR_BIT - pos);
// 并行计算设置位。
// r = (r & 0x5555...) + ((r >> 1) & 0x5555...);
r = r - ((r >> 1) & ~0UL/3);
// r = (r & 0x3333...) + ((r >> 2) & 0x3333...);
r = (r & ~0UL/5) + ((r >> 2) & ~0UL/5);
// r = (r & 0x0f0f...) + ((r >> 4) & 0x0f0f...);
r = (r + (r >> 4)) & ~0UL/17;
//r = r%255；
r = (r * (~0UL/255)) >> ((sizeof(v) - 1) * CHAR_BIT);
Juha Järvi 于 2009 年 11 月 21 日将此作为逆运算发送给我 接下来计算具有给定等级的位位置。

选择具有给定计数（等级）的位位置（从最高有效位开始）
以下 64 位代码选择第 r 个 1 位的位置 从左边数的时候。换句话说，如果我们开始 在最高有效位并向右继续， 计算设置为 1 的位数，直到达到所需的等级 r， 然后返回我们停止的位置。如果请求的排名超过 设置的位数，则返回 64。 代码可能会被修改为 32 位或从右边计数。
uint64_t v; // 输入值以查找等级为 r 的位置。
unsigned int r; //输入：位所需的等级[1-64]。
unsigned int s; // 输出：等级 r 的位的结果位置[1-64]
uint64_t a, b, c, d; // 位计数的中间临时变量。
unsigned int t; // 位计数临时值。 // 对 64 位整数进行正常的并行位计数，
// 但存储所有中间步骤。
// a = (v & 0x5555...) + ((v >> 1) & 0x5555...);
a = v - ((v >> 1) & ~0UL/3);
// b = (a & 0x3333...) + ((a >> 2) & 0x3333...);
b = (a & ~0UL/5) + ((a >> 2) & ~0UL/5);
// c = (b & 0x0f0f...) + ((b >> 4) & 0x0f0f...);
c = (b + (b>> 4)) & ~0UL/0x11;
// d = (c & 0x00ff...) + ((c >> 8) & 0x00ff...);
d = (c + (c >> 8)) & ~0UL/0x101;
t = (d >> 32) + (d >> 48);
// 现在进行无分支选择！
s＝64；
// 如果（r > t）{s - = 32; r - = t;}
s -= ((t - r) & 256) >> 3; r -= (t & ((t - r) >> 8));
t = (d>>(s-16))&0xff;
// 如果（r > t）{s - = 16; r - = t;}
s -= ((t - r) & 256) >> 4; r -= (t & ((t - r) >> 8));
t = (c>>(s-8))&0xf;
// 如果（r > t）{s - = 8; r - = t;}
s -= ((t - r) & 256) >> 5; r -= (t & ((t - r) >> 8));
t = (b>>(s-4))&0x7;
// 如果 (r > t) {s -= 4; r -= t;}
s -= ((t - r) & 256) >> 6; r -= (t & ((t - r) >> 8));
t = (a>>(s-2))&0x3;
// 如果 (r > t) {s -= 2; r -= t;}
s -= ((t - r) & 256) >> 7; r -= (t & ((t - r) >> 8));
t = (v>>(s-1))&0x1;
// 如果（r>t）s--；
s -= ((t - r) & 256) >> 8;
s = 65-s；
如果目标 CPU 上的分支执行速度很快，请考虑取消注释 if 语句并注释其后的各行。
Juha Järvi 于 2009 年 11 月 21 日将此信息发送给我。


简单计算奇偶校验
unsigned int v; // 计算奇偶校验的字值
bool parity = false; // parity 将是 vwhile (v) 的奇偶校验
{
奇偶校验=！奇偶校验；
v = v & (v - 1);
}

上述代码使用了类似 Brian Kernigan 的位计数方法。 所花费的时间与设置的位数成正比。

通过查找表计算奇偶校验
静态 const bool ParityTable256[256] =
{
# 定义 P2(n) n, n^1, n^1, n
# 定义 P4(n) P2(n), P2(n^1), P2(n^1), P2(n)
# 定义 P6(n) P4(n), P4(n^1), P4(n^1), P4(n)
P6(0)、P6(1)、P6(1)、P6(0)
};unsigned char b; // 用于计算奇偶校验的字节值
bool parity = ParityTable256[b];// 或，对于 32 位字：
无符号整数 v；
v ^=v>> 16;
v ^=v>> 8;
bool parity = ParityTable256[v & 0xff];// 变化：
无符号字符*p = (无符号字符*)&v;
奇偶校验 = ParityTable256[p[0] ^ p[1] ^ p[2] ^ p[3]];

Randal E. Bryant 鼓励添加（公认的）显而易见的 最后一次使用变量 p 的变体是在 2005 年 5 月 3 日。Bruce Rawles 发现了一个拼写错误 在 2005 年 9 月 27 日的表变量名称实例中，以及 他获得了 10 美元的漏洞赏金。2006 年 10 月 9 日，Fabrice Bellard 建议使用上述 32 位变体，只需要一次表查找； 以前的版本有四次查找（每个字节一次）并且速度较慢。 2009 年 7 月 14 日，Hallvard Furuseth 提出了宏压缩表。

使用 64 位乘法和模数除法计算字节的奇偶校验
unsigned char b; // 用于计算奇偶校验的字节值
布尔奇偶校验=
(((b * 0x010101010101010101ULL) & 0x8040201008040201ULL) % 0x1FF) & 1;
上述方法大约需要 4 个操作，但仅适用于字节。

用乘法计算字的奇偶校验
以下方法仅用 8 个字节计算 32 位值的奇偶校验 使用乘法进行运算。
unsigned int v; // 32 位字
v ^=v>> 1;
v ^=v>> 2;
v = (v & 0x11111111U) * 0x11111111U;
返回（v >> 28）&1；
对于 64 位来说，8 次操作仍然足够。
unsigned long long v; // 64 位字
v ^=v>> 1;
v ^=v>> 2;
v = (v & 0x1111111111111111UL) * 0x111111111111111UL;
返回（v >> 60）&1；
安德鲁·夏皮拉 (Andrew Shapira) 想出了这个主意并于 2007 年 9 月 2 日将其发送给了我。

并行计算奇偶校验
unsigned int v; // 计算奇偶校验的字值
v ^=v>> 16;
v ^=v>> 8;
v ^=v>> 4;
在 &= 0xf;
返回（0x6996 >> v）&1；
上述方法大约需要 9 次操作，适用于 32 位字。 可以通过删除以下代码进行优化，使其在 5 次操作中仅对字节进行操作 紧跟在“unsigned int v;”后面的两行。该方法首先转移 并将 32 位值的八个半字节进行异或运算，结果为 在 v 的最低半字节中。接下来是二进制数 0110 1001 1001 0110 （十六进制为 0x6996）向右移动最低位所表示的值 v 的半字节。这个数字就像一个微型 16 位奇偶校验表，索引为 v 的低四位。结果在第 1 位具有 v 的奇偶校验，即 戴上面具返回。
感谢 Mathew Hendry 在 2002 年 12 月 15 日指出了移位查找的想法。该优化减少了两个操作，仅使用移位和异或运算来查找奇偶校验。


用减法和加法交换值
#定义 SWAP(a，b) ((&(a) == &(b)) || \
(((a) -= (b)), ((b) += (a)), ((a) = (b) - (a))))
这将交换 a 和 b 的值 ，而无需使用临时变量。 最初检查 a 和 b 是否位于内存中的同一位置可能是 当你知道这不会发生时，可以省略它。（编译器可能会忽略它） 作为优化。）如果启用溢出异常，则传递无符号 值，所以不会引发异常。 后面的 XOR 方法在某些机器上可能会稍微快一些。 不要将其与浮点数一起使用（除非你操作 它们的原始整数表示）。
Sanjeev Sivasankaran 建议我在 2007 年 6 月 12 日添加此内容。Vincent Lefèvre 于 2008 年 7 月 9 日指出了溢出异常的可能性

使用 XOR 交换值
#定义 SWAP(a，b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))
这是一个交换变量 a 和 b 值的老把戏 无需为临时变量使用额外的空间 。
2005 年 1 月 20 日，Iain A. Fleming 指出，当交换相同的内存位置时，上述宏不起作用，例如 SWAP(a[i], a[j]) 中 i == j。因此，如果可能发生这种情况，请考虑将宏定义为 (((a) == (b)) || (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b))))。2009 年 7 月 14 日，Hallvard Furuseth 建议，在某些机器上， (((a) ^ (b)) && ((b) ^= (a) ^= (b), (a) ^= (b))) 可能更快，因为 (a) ^ (b) 表达式被重用了。


使用 XOR 交换单个位
unsigned int i, j; // 要交换的位序列的位置
unsigned int n; // 每个序列中连续位数
unsigned int b; // 要交换的位位于 b 中
unsigned int r; // 位交换结果存放于此 unsigned int x = ((b >> i) ^ (b >> j)) & ((1U << n) - 1); // 异或临时值
r = b ^ ((x << i) | (x << j));
作为交换位范围的示例 假设我们有 b = 001 0 111 1 （以二进制表示）并且我们想要交换 n = 3 个连续的位 从 i = 1 （右边第二位）开始，连续 3 个 从 j = 5 开始的位；结果将是 r = 111 0 001 1（二进制）。
这种交换方法类似于通用的异或交换技巧，但旨在对单个位进行操作。变量 x 存储了我们要交换的位值对的异或结果，然后将这些位设置为它们自己与 x 异或的结果。当然，如果序列重叠，则结果不确定。

2009 年 7 月 14 日，Hallvard Furuseth 建议我将 1 << n 更改为 1U << n，因为该值被分配给无符号数，并避免移入符号位。


以显而易见的方式反转比特
unsigned int v; // 要反转的输入位
unsigned int r = v; // r 将是 v 的反转位；首先获取 v 的 LSB
int s = sizeof(v) * CHAR_BIT - 1; // endfor 时需要额外移位 (v >>= 1; v; v >>= 1)
{   
r<<=1；
r |= v & 1;
s--；
}
r <<= s; // 当 v 的最高位为零时移位
2004 年 10 月 15 日，Michael Hoisie 指出了原始版本中的一个错误。2005 年 5 月 3 日，Randal E. Bryant 建议删除一个额外的操作。2005 年 5 月 18 日，Behdad Esfabod 建议进行一些小改动，消除了循环中的一次迭代。之后，2007 年 2 月 6 日，Liyong Zhou 提出了一个更好的版本，当 v 不为 0 时循环，这样它就不再迭代所有位，而是提前停止。


通过查找表反转字中的位
静态 const 无符号 char BitReverseTable256[256] =
{
# 定义 R2(n) n, n + 2*64, n + 1*64, n + 3*64
# 定义 R4(n) R2(n), R2(n + 2*16), R2(n + 1*16), R2(n + 3*16)
# 定义 R6(n) R4(n), R4(n + 2*4), R4(n + 1*4), R4(n + 3*4)
R6(0)、R6(2)、R6(1)、R6(3)
};unsigned int v; // 反转 32 位值，每次 8 位
unsigned int c; // c 将使 v 反转// 选项 1：
c = (BitReverseTable256[v & 0xff] << 24) |
(BitReverseTable256[(v >> 8) & 0xff] << 16) |
(BitReverseTable256[(v >> 16) & 0xff] << 8) |
(BitReverseTable256[(v >> 24) & 0xff]);//选项 2:
无符号字符*p = (无符号字符*)&v;
无符号字符*q =（无符号字符*）&c;
q[3] = 位反向表 256[p[0]];
q[2] = 位反向表 256[p[1]];
q[1] = BitReverseTable256[p[2]];
q[0] = BitReverseTable256[p[3]];
第一种方法大约需要 17 次运算，第二种方法大约需要 12 次运算， 假设您的 CPU 可以轻松加载和存储字节。
2009 年 7 月 14 日，Hallvard Furuseth 提出了宏压缩表。


使用 3 个运算（64 位乘法和模数除法）反转字节中的位：
unsigned char b; // 反转此（8 位）byteb = (b * 0x0202020202ULL & 0x010884422010ULL) % 1023;
乘法运算创建了 8 位 字节模式散开为 64 位值。 AND 运算选择正确（反转）的位 位置，相对于每个 10 位组的位。 乘法和与运算复制原始 字节，因此它们各自仅出现在 10 位集合中的一个中。 原始字节中位的反转位置与 它们在任何 10 位集合内的相对位置。 最后一步涉及模数除以 2^10 - 1，其结果为 将每组 10 位合并在一起的效果 （从位置 0-9、10-19、20-29、...）在 64 位值中。 它们不重叠，因此 模数除法的行为类似于或运算。
该方法归功于 Rich Schroeppel 编程技巧部分 Beeler, M.、Gosper, RW 和 Schroeppel, R. HAKMEM。麻省理工学院人工智能备忘录 239，1972 年 2 月 29 日。


使用 4 个运算（64 位乘法，无除法）反转字节中的位：
unsigned char b; // 反转此字节 b = ((b * 0x80200802ULL) & 0x0884422110ULL) * 0x0101010101ULL >> 32;
下面显示了布尔变量的位值流 a, b, c, d, e, f, g, 和 h ，其中 包含一个 8 位字节。注意第一个乘法如何将 位模式复制到多个副本，而最后一个乘法将它们组合起来 在右边的第五个字节。
abcd efgh (-> hgfe dcba)
* 1000 0000 0010 0000 0000 1000 0000 0010 (0x80200802)
-------------------------------------------------------------------------------------------------
0abc defg h00a bcde fgh0 0abc defg h00a bcde fgh0
& 0000 1000 1000 0100 0100 0010 0010 0010 0001 0001 0000 (0x0884422110)
-------------------------------------------------------------------------------------------------
0000 d000 h000 0c00 0g00 00b0 00f0 000a 000e 0000
* 0000 0001 0000 0001 0000 0001 0000 0001 0000 0001 0000 0001 (0x0101010101)
-------------------------------------------------------------------------------------------------
0000 d000 h000 0c00 0g00 00b0 00f0 000a 000e 0000
0000 d000 h000 0c00 0g00 00b0 00f0 000a 000e 0000
0000 d000 h000 0c00 0g00 00b0 00f0 000a 000e 0000
0000 d000 h000 0c00 0g00 00b0 00f0 000a 000e 0000
0000 d000 h000 0c00 0g00 00b0 00f0 000a 000e 0000
-------------------------------------------------------------------------------------------------
0000 d000 h000 dc00 hg00 dcb0 hgf0 dcba hgfe dcba hgfe 0cba 0gfe 00ba 00fe 000a 000e 0000
>> 32
-------------------------------------------------------------------------------------------------
0000 d000 h000 dc00 hg00 dcb0 hgf0 dcba hgfe dcba
&                                                                                       1111 1111
-------------------------------------------------------------------------------------------------
氢氟酸二丁酯
请注意，在某些处理器上，最后两个步骤可以合并，因为 寄存器可以作为字节进行访问； 只需进行乘法运算，以便寄存器存储结果的高 32 位 然后取低字节。因此，可能只需要6次操作。
由 Sean Anderson 于 2001 年 7 月 13 日设计。


使用 7 次操作来反转一个字节中的位（无 64 位）：
b = ((b * 0x0802LU & 0x22110LU) | (b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16; 
确保将结果赋值或转换为无符号字符以删除 高位中的垃圾。 由 Sean Anderson 于 2001 年 7 月 13 日设计。已发现拼写错误并已提供更正 作者：Mike Keith，2002 年 1 月 3 日。

通过 5 * lg(N) 次操作并行反转 N 位数：
unsigned int v; // 32 位字以反转位顺序//交换奇数位和偶数位
v = ((v >> 1) & 0x55555555) | ((v & 0x55555555)<< 1);
// 交换连续对
v = ((v >> 2) & 0x33333333) | ((v & 0x33333333)<< 2);
// 交换半字节...
v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
// 交换字节
v = ((v >> 8) & 0x00FF00FF) | ((v&0x00FF00FF)<< 8);
// 交换 2 字节长对
v = ( v >> 16 ) | (v<< 16);
以下变体也是 O(lg(N))，但它需要更多 操作来逆转 v。它的优点是占用较少的内存 通过动态计算常数。
unsigned int s = sizeof(v) * CHAR_BIT; // 位大小；必须是 2 的幂
无符号整数掩码=~0；
当（（s>> = 1）> 0）
{
掩码 ^= (掩码 << s);
v = ((v >> s) & 掩码) | ((v << s) & ~mask);
}
上述这些方法最适合于 N 较大的情况。 如果你使用上面的 64 位整数（或更大），那么你需要 添加更多线条（遵循模式）；否则只有较低的 32 位将被反转，结果将位于低 32 位。
更多信息请参阅 Edwin Freed 在 1983 年出版的《Dr. Dobb's Journal》中关于二进制魔法数的文章。第二种变体由 Ken Raeburn 于 2005 年 9 月 13 日提出。Veldmeijer 在 2006 年 3 月 19 日的最后一行提到，第一个版本可以不使用 ANDS。


计算模数除以 1 << s，不使用除法运算符
const unsigned int n; //分子
const 无符号整数 s;
const unsigned int d = 1U << s; // 因此 d 将是以下之一：1、2、4、8、16、32、...
unsigned int m; // m 将是 n % d
m = n & (d - 1);
大多数程序员很早就学会了这个技巧，但它是为 为了完整性。


计算模数除以 (1 << s) - 1，不使用除法运算符
unsigned int n; //分子
const unsigned int s; // s > 0
const unsigned int d = (1 << s) - 1; // 所以 d 要么是 1，3，7，15，31，...)。
unsigned int m; // n % d 到这里。for (m = n; n > d; n = m)
{
对于（m = 0；n；n>>=s）
  {
m += n & d;
  }
}
// 现在 m 是从 0 到 d 的值，但是由于模数除法
// 我们希望当 m 为 d 时其为 0。
m = m == d ?0 : m;
这种除以小于幂的整数的模数方法 最多 2 次 5 + (4 + 5 * ceil(N / s)) * ceil(lg(N / s)) 运算，其中 N 是 分子中的位数。换句话说，最多需要 O(N * lg(N)) 时间。
由 Sean Anderson 于 2001 年 8 月 15 日设计。在 Sean A. Irvine 纠正我之前 2004 年 6 月 17 日，我错误地评论说，我们可以另外分配 m = ((m + 1) & d) - 1; 结尾。Michael Miller 于 2005 年 4 月 25 日发现了代码中的拼写错误。


不使用除法运算符，并行计算模数除以 (1 << s) - 1
// 以下是针对 32 位字大小的静态 const unsigned int M[] = { 0x00000000, 0x55555555, 0x33333333, 0xc71c71c7, 0x0f0f0f0f, 0xc1f07c1f, 0x3f03f03f, 0xf01fc07f, 0x00ff00ff, 0x07fc01ff, 0x3ff003ff, 0xffc007ff, 0xff000fff, 0xfc001fff, 0xf0003fff, 0xc0007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff };静态 const unsigned int Q[][6] = { { 0, 0, 0, 0, 0, 0}, {16, 8, 4, 2, 1, 1}, {16, 8, 4, 2, 2, 2}, {15, 6, 3, 3, 3, 3}, {16, 8, 4, 4, 4, 4}, {15, 5, 5, 5, 5, 5}、{12、6、6、6、6、6}、{14、7、7、7、7、7}、{16、8、8、8、8、8}、{9、9、9、9、9、9}、{10、10、10、10、10、10}、{11、 11, 11, 11, 11, 11}, {12, 12, 12, 12, 12, 12}, {13, 13, 13, 13, 13, 13}, {14, 14, 14, 14, 14, 14}, {15, 15, 15, 15, 15, 15}, {16, 16, 16, 16, 16, 16}, {17, 17, 17, 17, 17, 17}, {18, 18, 18, 18, 18, 18}, {19, 19, 19, 19, 19, 19}, {20, 20, 20, 20, 20, 20}, {21, 21, 21, 21, 21, 21}, {22, 22, 22, 22, 22, 22}, {23, 23, 23, 23, 23, 23}, {24, 24, 24, 24, 24, 24}, {25, 25, 25, 25, 25, 25}, {26, 26, 26, 26, 26, 26}, {27, 27, 27, 27, 27, 27}, {28, 28, 28, 28, 28, 28}, {29, 29, 29, 29, 29, 29}, {30, 30, 30, 30, 30}, {31, 31, 31, 31, 31, 31} };静态 const unsigned int R[][6] = { {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, {0x0000ffff, 0x000000ff, 0x0000000f, 0x00000003, 0x00000001, 0x00000001}, {0x0000ffff, 0x000000ff, 0x0000000f, 0x00000003, 0x00000003, 0x00000003}, {0x00007fff, 0x0000003f, 0x00000007, 0x00000007, 0x00000007}, {0x0000ffff, 0x000000ff, 0x0000000f, 0x0000000f, 0x0000000f, 0x0000000f}, {0x00007fff, 0x0000001f, 0x0000001f, 0x0000001f, 0x0000001f, 0x0000001f}, {0x00000fff, 0x0000003f, 0x0000003f, 0x0000003f, 0x0000003f}, {0x00003fff, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f}，{0x0000ffff，0x000000ff，0x000000ff，0x000000ff，0x000000ff，0x000000ff}，{0x000001ff，0x000001ff，0x000001ff，0x000001ff，0x000001ff，0x000001ff}，{0x000003ff，0x000003ff，0x000003ff，0x000003ff，0x000003ff，0x000003ff}，{0x000007ff，0x000007ff，0x000007ff， 0x000007ff, 0x000007ff, 0x000007ff}, {0x00000fff, 0x00000fff, 0x00000fff, 0x00000fff, 0x00000fff, 0x00000fff}, {0x00001fff, 0x00001fff, 0x00001fff, 0x00001fff, 0x00001fff, 0x00001fff}, {0x00003fff, 0x00003fff, 0x00003fff, 0x00003fff, 0x00003fff}, {0x00007fff, 0x00007fff, 0x00007fff, 0x00007fff, 0x00007fff, 0x00007fff}, {0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff}, {0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}, {0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff}, {0x0007ffff, 0x0007ffff, 0x0007ffff, 0x0007ffff, 0x0007ffff, 0x0007ffff}, {0x000fffff, 0x000fffff, 0x000ffff, 0x000fffff, 0x000fffff, 0x000fffff}, {0x001fffff, 0x001fffff, 0x001fffff, 0x001fffff, 0x001fffff, 0x001fffff}, {0x003fffff, 0x003fffff, 0x003fffff, 0x003fffff, 0x003fffff}, {0x007fffff, 0x007fffff, 0x007fffff, 0x007fffff, 0x007fffff, 0x007fffff}, {0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff}, {0x01ffffff, 0x01ffffff, 0x01ffffff, 0x01ffffff, 0x01ffffff, 0x01ffffff}, {0x03ffffff, 0x03ffffff, 0x03ffffff, 0x03ffffff, 0x03ffffff}, {0x07ffffff, 0x07ffffff, 0x07ffffff, 0x07ffffff, 0x07ffffff, 0x07ffffff}, {0x0fffffff, 0x0fffffff, 0x0fffffff, 0x0fffffff, 0x0ffffff, 0x0ffffff}, {0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff}, {0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff}, {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff} };unsigned int n; // 分子 const unsigned int s; // s > 0 const unsigned int d = (1 << s) - 1; // 所以 d 是 1、3、7、15、31、...)。 unsigned int m; // n % d 在此处。m = (n & M[s]) + ((n >> s) & M[s]);for (const unsigned int * q = &Q[s][0], * r = &R[s][0]; m > d; q++, r++) { m = (m >> *q) + (m & *r); } m = m == d ? 0 : m; // 或，移植性较差：m = m & -((signed)(m - d) >> s);
这种求模除法的方法，用一个整数减一 比 2 的幂最多需要 O(lg(N)) 时间，其中 N 是 分子中的位（对于上面的代码，为 32 位）。 操作次数最多为 12 + 9 * ceil(lg(N))。 如果您知道，表格可能会被移除 编译时的分母；只需提取几个相关条目 并展开循环。它可以很容易地扩展到更多位。
它通过并行求和基数 (1 << s) 中的值来找到结果。首先，每个其他基数 (1 << s) 的值都添加到前一个值上。想象一下，结果写在一张纸上。将纸剪成两半，每剪下的部分都有一半的值。对齐这些值并将它们相加到一张新纸上。重复将这张纸剪成两半（大小将是前一张纸的四分之一）并相加，直到无法再剪。在执行 lg(N/s/2) 次切割后，我们不再切割；只需继续将值相加并将结果像以前一样放在一张新纸上，同时至少有两个 s 位值。

由 Sean Anderson 于 2001 年 8 月 20 日设计。 Randy E. Bryant 于 2005 年 5 月 3 日（粘贴代码后，我后来 在变量声明中添加了“unsinged”）。就像上一个 hack 一样， 我错误地评论说我们可以另外分配 m = ((m + 1) & d) - 1; 最后，Don Knuth 修正了 2006 年 4 月 19 日，我建议 m = m & -((signed)(m - d) >> s) . 2009 年 6 月 18 日，Sean Irvine 提出了一项变更，使用 ((n >> s) & M[s]) 而不是 ((n & ~M[s]) >> s) ，这通常需要较少的操作，因为 M[s] 常量已经加载。


通过 O(N) 次运算找到 MSB 为 N 的整数的对数底数为 2（显而易见的方法）
unsigned int v; // 32 位字，用于查找以 2 为底的对数
unsigned int r = 0; // r 将为 lg(v)while (v >>= 1) // 展开以获得更快的速度...
{
r++；
}
整数的对数底数为 2，其最高位的位置相同 位集（或最高有效位集，MSB）。以下对数以 2 为底 方法比这个更快。

用 64 位 IEEE 浮点数计算以 2 为底的整数对数
int v; // 32 位整数，用于计算以 2 为底的对数
int r; // log_2(v) 的结果放在这里
联合 { 无符号整数 u[2]; 双精度 d; } t; // tempt.u[__FLOAT_WORD_ORDER==LITTLE_ENDIAN] = 0x43300000;
tu[__FLOAT_WORD_ORDER!=LITTLE_ENDIAN] = v;
TD-=4503599627370496.0；
r = (tu[__FLOAT_WORD_ORDER==LITTLE_ENDIAN] >> 20) - 0x3FF;
上面的代码加载了一个 64 位（IEEE-754 浮点）双精度数， 一个 32 位整数（无填充位），通过将整数存储在 尾数，而指数设置为 2 52 。 从这个新生的双胞胎， 减去 2 52 （以双精度数表示），这将设置 得到的对数指数为输入值 v 的底数为 2。 左边是将指数位移位到位（右边 20 位）， 减去偏差 0x3FF（十进制为 1023）。这种技术 只需要 5 次操作，但许多 CPU 在处理双精度数时速度很慢， 并且必须适应架构的字节顺序。
Eric Cole 于 2006 年 1 月 15 日将此发给我。Evan Felix 于 2006 年 4 月 4 日指出了一个打字错误。Vincent Lefèvre 于 2008 年 7 月 9 日告诉我将字节序检查改为使用浮点数的字节序，这可能与整数的字节序不同。


使用查找表查找整数的以 2 为底的对数
静态 const char LogTable256[256] =
{
#定义 LT(n) n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n
    -1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
LT(4), LT(5), LT(5), LT(6), LT(6), LT(6), LT(6),
LT(7), LT(7), LT(7), LT(7), LT(7), LT(7), LT(7), LT(7)
};unsigned int v; // 32 位字来查找对数
无符号 r；//r 将是 lg(v)
注册无符号整数 t，tt；//临时 if（tt = v>> 16）
{
r = (t = tt >> 8) ?24 + LogTable256[t] : 16 + LogTable256[tt];
}
别的
{
r = (t = v >> 8) ? 8 + LogTable256[t] : LogTable256[v];
}
查找表方法只需要大约 7 次操作就可以找到 32 位值。如果扩展到 64 位数量，则大约需要 9 个操作。另一个操作可以通过使用四个表来修剪， 并将可能的附加项纳入其中。使用 int 表 元素可能会更快，这取决于您的架构。
上述代码已调整为输出值均匀分布。如果您的输入均匀分布在所有 32 位值中，请考虑使用以下代码：

如果（tt = v >> 24）
{
r = 24 + LogTable256[tt];
} 
否则，如果（tt = v >> 16）
{
r = 16 + LogTable256[tt];
} 
否则，如果（tt = v >> 8）
{
r = 8 + LogTable256[tt];
} 
别的
{
r = LogTable256[v];
}
最初以算法方式生成日志表：
LogTable256[0] = LogTable256[1] = 0;
对于（int i = 2；i< 256；i ++）
{
LogTable256[i] = 1 + LogTable256[i / 2];
}
LogTable256[0] = -1; //如果你想让 log(0)返回-1
Behdad Esfahbod 和我平均减少了一小部分手术费用 2005 年 5 月 18 日。11 月，又有一部分手术被切除。 2006 年 14 日，Emanuel Hoogeveen 创作。 分布式输入值由 David A. Butterfield 于 9 月提出 2008 年 1 月 19 日。Venkat Reddy 在 2009 年 1 月 5 日告诉我，log(0) 应该返回 -1 表示错误，因此我将表中的第一个条目更改为该值。
在 O(lg(N)) 次运算中求出 N 位整数的对数底数为 2
unsigned int v; // 用于计算 log2 的 32 位值
const unsigned int b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};
const unsigned int S[] = {1, 2, 4, 8, 16};
int i;register unsigned int r = 0; // log2(v) 的结果将放在这里
for (i = 4; i >= 0; i--) // 展开以提高速度...
{
如果（v＆b [i]）
  {
v>>=S[i]；
r |= S[i];
  } 
}
// 或（如果您的 CPU 分支缓慢）：unsigned int v; // 用于查找 log2 的 32 位值
注册无符号整数 r；//log2（v）的结果将放在这里
注册无符号整数移位；r = (v > 0xFFFF) << 4; v >>= r;
移位 = (v> 0xFF)<< 3; v>>=移位; r |=移位;
移位 = (v> 0xF)<< 2; v>>=移位; r |=移位;
移位 = （v > 0x3 ）<< 1；v >>=移位；r |=移位；
r |= (v >> 1);
// 或（如果您知道 v 是 2 的幂）：unsigned int v; // 用于计算 log2 的 32 位值
静态 const 无符号 int b[] = {0xAAAAAAAA， 0xCCCCCCCC， 0xF0F0F0F0，
0xFF00FF00, 0xFFFF0000}；
注册无符号整数 r = (v & b[0]) != 0;
for (i = 4; i > 0; i--) // 展开以提高速度...
{
r |= ((v & b[i]) != 0) << i;
}
当然，要扩展代码来查找 33 位到 64 位的日志 数字，我们会将另一个元素 0xFFFFFFFF00000000 附加到 b， 将 32 附加到 S，并从 5 循环到 0。这种方法要慢得多 比早期的表格查找版本，但如果你不想要大表 或者您的架构访问内存很慢，这是一个不错的选择。 第二种变化涉及的操作稍微多一些，但可能 在分支成本较高的机器上速度更快（例如 PowerPC）。
第二个版本是 埃里克·科尔 2006 年 1 月 7 日。Andrew Shapira 随后对一些手术进行了 并于 2007 年 9 月 1 日将他的变奏版（上图）发给了我。 第三个变种是由 约翰·欧文斯 2002 年 4 月 24 日；速度更快，但是 它只适用于已知输入为 2 的幂的情况 。2003 年 5 月 25 日，Ken Raeburn 建议改进一般情况，使用较小的 b[] 数值，这样在某些架构上加载速度更快（例如，如果字长为 16 位，则可能只需要一条加载指令）。这些值适用于一般版本，但不适用于低于该版本的特殊情况，其中 v 是 2 的幂；Glenn Slayden 于 2003 年 12 月 12 日向我反映了这个疏忽。


通过乘法和查找，在 O(lg(N)) 运算中查找 N 位整数的对数底数为 2
uint32_t v; // 计算 32 位 v 的以 2 为底的对数
int r; // 结果在这里 static const int MultiplyDeBruijnBitPosition[32] =
{
  0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,
  8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31
};v |= v >> 1; // 首先向下舍入到小于 2 的幂
v |= v >> 2;
v |= v >> 4;
v |= v >> 8;
v |= v >> 16;r = MultiplyDeBruijnBitPosition[(uint32_t)(v * 0x07C4ACDDU) >> 27];
上面的代码计算了 32 位整数的以 2 为底的对数 一个简单的查表和乘法。它只需要 13 次运算， 相比之前的方法（最多）20。纯粹基于表格的 方法需要的操作最少，但这提供了 表格大小和速度之间的合理折衷。
如果您知道 v 是 2 的幂，那么您只需要以下内容：

静态 const int MultiplyDeBruijnBitPosition2[32] =
{
  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
};
r = MultiplyDeBruijnBitPosition2[(uint32_t)(v * 0x077CB531U) >> 27];
Eric Cole 在 2006 年 1 月 8 日读到下面的条目后设计了这个，以便将数字四舍五入为 2 的幂 ，并且 下面的方法 使用德布鲁因序列进行乘法和查找，计算尾随位数 。2009 年 12 月 10 日，Mark Dickinson 通过要求 v 向上舍入为比下一个 2 的幂小 1 而不是 2 的幂，从而减少了几个运算。


计算以 10 为底的整数对数
unsigned int v; // 用于计算以 10 为底的对数的非零 32 位整数值
int r; // 结果放在这里
int t; //临时静态无符号整数 const PowersOf10[] =
    {1, 10, 100, 1000, 10000, 100000,
1000000, 10000000, 100000000, 1000000000};t = (IntegerLogBase2(v) + 1) * 1233 >> 12; //（使用上面的 lg2 方法）
r = t - (v<10 的幂[t]);
首先使用上述技术之一来计算以 10 为底的整数对数 求对数底数 2。通过关系 log 10 (v) = log 2 (v) / log 2 (10)，我们需要将其乘以 1/log 2 (10)，约为 1233/4096，或 1233，然后右移 12 位。需要加一，因为 IntegerLogBase2 向下取整。最后，由于值 t 只是一个 近似值可能有一个偏差，确切值可以通过以下方法找到 减去 v < PowersOf10[t] 的结果。
此方法比 IntegerLogBase2 多需要 6 次运算。可以通过修改上述以 2 为底的对数查表方法来加快速度（在内存访问速度较快的机器上），使条目保存对 t 的计算结果（即预加、乘法和移位）。假设使用 4 个表（v 的每个字节对应一个表），这样做只需要 9 次运算即可找到以 10 为底的对数。

2006 年 1 月 7 日，Eric Cole 建议我添加此版本。


用显而易见的方法求出以 10 为底的整数对数
unsigned int v; // 用于计算以 10 为底的对数的非零 32 位整数值
int r; // 结果放在这里 er = (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
（在 >=1000000）？ 6 ：（v >= 100000）？ 5 ：（v >= 10000）？ 4：
（在 >=1000）？ 3 ：（v>=100）？ 2 ：（v>=10）？ 1 ： 0；
当输入均匀分布在 32 位上时，此方法效果很好 值，因为 76% 的输入被第一次比较捕获，21% 被第二次比较捕获，2% 被第三次比较捕获，依此类推 （每次比较时将剩余部分减少 90%）。 因此，平均需要的手术次数少于 2.6 次。
2007 年 4 月 18 日，Emanuel Hoogeveen 提出了一种变体，其中条件使用除法，但速度不如简单比较快。

计算 32 位 IEEE 浮点数的以 2 为底的整数对数
const 浮点数 v; // 查找 int(log2(v))，其中 v > 0.0 && 有限(v) && isnormal(v)
int c; // 32 位 int c 获取结果；c = *(const int *) &v; // 或，为了可移植性：memcpy(&c, &v, sizeof c);
c = (c>> 23) - 127;
上述速度很快，但符合 IEEE 754 的架构利用 次正规 （也称为非正规 ） 浮点数。这些数的指数位设置为零 （表示 pow(2,-127)）， 尾数未标准化，因此包含前导零和 因此，必须根据尾数计算 log2。为了适应 次正规数，请使用以下命令：
const float v; // 查找 int(log2(v))，其中 v > 0.0 && finite(v)
int c; //32 位 int c 获取结果；
int x = *(const int *) &v; // 或，为了可移植性：memcpy(&x, &v, sizeof x);c = x >> 23; if (c)
{
c-=127；
}
别的
{ // 低于正常水平，因此使用尾数重新计算：c = intlog2(x) - 149;
注册无符号整数 t；//临时
// 注意 LogTable256 之前已经定义过了
如果（t = x >> 16）
  {
c = LogTable256[t]-133；
  }
别的
  {
c = (t = x >> 8) ? LogTable256[t] - 141 : LogTable256[x] - 149;
  }
}
2004 年 6 月 20 日，Sean A. Irvine 建议我添加代码来处理 次正规数。2005 年 6 月 11 日，Falk Hüffner 指出 ISO C99 6.5/7 为常见类型双关语指定了未定义的行为 *(int *)&，尽管它在 99.9% 的 C 编译器上都能工作。 他建议使用 memcpy 来实现最大的可移植性，或者使用浮点型联合 并且在某些编译器上，int 可以比 memcpy 生成更好的代码。

计算 32 位 IEEE 浮点数的 pow(2, r)-root 的以 2 为底的整数对数（对于无符号整数 r）
const int r;
const float v; // 查找 int(log2(pow((double) v, 1. / pow(2, r))))，
// 其中 isnormal(v) 且 v > 0
int c; // 32 位 int c 获取结果；c = *(const int *) &v; // 或，为了可移植性：memcpy(&c, &v, sizeof c);
c = ((((c - 0x3f800000) >> r) + 0x3f800000) >> 23) - 127;
因此，例如，如果 r 为 0，则我们有 c = int(log2((double) v))。 如果 r 为 1，则我们有 c = int(log2(sqrt((double) v)))。 如果 r 是 2，那么我们有 c = int(log2(pow((double) v, 1./4)))。
2005 年 6 月 11 日，Falk Hüffner 指出 ISO C99 6.5/7 未定义类型双关语习语 *(int *)&，他建议使用 memcpy。


线性计算右侧连续的零位（尾随）
unsigned int v; // 输入以计数尾随零位
int c; // 输出：c 将计算 v 的尾随零位，
// 因此如果 v 是 1101000（以 2 为基数），那么 c 将是 3
如果（v）
{
v = (v ^ (v - 1)) >> 1; // 将 v 的尾随 0 设置为 1，其余部分为零
对于（c = 0; v; c++）
  {
v>>= 1;
  }
}
别的
{
c = CHAR_BIT * sizeof(v);
}
尾随零位的平均数量（均匀分布） 随机二进制数为 1，因此这个 O（尾随零）解决方案不是 与下面更快的方法相比，这很糟糕。
2007 年 8 月 15 日，Jim Cole 建议我添加一个线性时间方法来计算尾随零的数量。2007 年 10 月 22 日，Jason Cunningham 指出我忘记粘贴 v 的无符号修饰符了。

并行计算右侧连续的零位（尾随）
unsigned int v; // 32 位字输入，用于计算右侧的零位
unsigned int c = 32; // c 将是右边零位数
v &= -signed(v);
如果（v）c--；
如果 (v & 0x0000FFFF) c - = 16;
如果 (v & 0x00FF00FF) c - = 8;
如果（v & 0x0F0F0F0F）c - = 4；
如果（v & 0x33333333）c - = 2；
如果（v&0x55555555）c-=1；
这里我们基本上做的操作和求对数底数 2 是一样的 并行，但我们首先隔离最低的 1 位，然后继续 c 从最大值开始逐渐减小。 对于 N 位字，操作次数大约最多为 3 * lg(N) + 4。
Bill Burdick 提出了优化建议，将时间从 2011 年 2 月 4 日的 4 * lg(N) 减少。


通过二分查找计算右侧连续的零位（尾随）
unsigned int v; // 32 位字输入，用于计算右侧的零位
unsigned int c; // c 将是右边零位数，
// 因此如果 v 是 1101000（以 2 为基数），那么 c 将是 3
// 注意：如果 0 == v，则 c = 31。
如果（v＆0x1）
{
// 奇数 v 的特殊情况（假设发生一半的时间）
c＝0；
}
别的
{
c＝1；
如果（（v＆0xffff）==0）
  {  
v>>=16；
c += 16;
  }
如果（（v＆0xff）==0）
  {  
v>>=8；
c += 8;
  }
如果（（v＆0xf）==0）
  {  
v>>=4；
c += 4;
  }
如果（（v＆0x3）==0）
  {  
v>>=2；
c += 2;
  }
c-=v&0x1；
}
上面的代码与之前的方法类似，但它计算的是 通过类似于二分搜索的方式累积 c 来消除尾随零。 第一步，检查 v 的低 16 位是否为零， 如果是，则将 v 右移 16 位，并将 c 加 16，从而减少 v 中需要考虑的位数减半。后续的每个 条件步骤同样将位数减半，直到只剩下 1。 这种方法比上一种方法快（约 33%），因为身体 if 语句的执行频率较低。
马特·惠特洛克 (Matt Whitlock) 于 2006 年 1 月 25 日提出了这个建议。安德鲁·夏皮拉 (Andrew Shapira) 于 2007 年 9 月 5 日减少了几个操作（通过设置 c=1 并在最后无条件减去）。


通过转换为浮点数来计算右侧连续的零位（尾随）
unsigned int v; // 找出 v 中尾随零的数量
int r; // 结果放在这里
float f = (float)(v & -v); // 将 v 中的最低有效位转换为浮点数
r = (*(uint32_t *)&f>> 23) - 0x7f;
虽然这只需要大约 6 次操作，但转换的时间 在某些机器上，整数到浮点数的转换可能很高。 32 位 IEEE 浮点数的指数 表示向下移动，并减去偏差，得到 v 中设置的最低有效 1 位的位置。 如果 v 为零，则结果为 -127。

通过模数除法和查找来计算右侧连续的零位（尾随）
unsigned int v; // 找出 v 中尾随零的数量
int r; // 将结果放入 r
static const int Mod37BitPosition[] = // 将位值 mod 37 映射到其位置
{
  32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4,
  7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5,
  20, 8, 19, 18
};
r = Mod37BitPosition[(-v & v) % 37];
上面的代码找到了右边尾随的零的数量，所以 二进制 0100 会产生 2。它利用了前 32 个 位位置值与 37 互质，因此执行模数 除以 37，每个数都会得到一个从 0 到 36 的唯一数字。这些数字 然后可以使用一个小的查找表将其映射到零的数量。 它只使用 4 个操作，但是索引到表中并执行模数 分裂可能会使其不适合某些情况。 我独立想出了这个，然后搜索了 表格值，并发现它是由 Reiser 更早发明的，根据 黑客的喜悦 。

使用乘法和查找来计算右侧连续的零位（尾随）
unsigned int v; // 找出 32 位 v 中尾随零的数量
int r; // 结果放在这里
静态 const int MultiplyDeBruijnBitPosition[32] =
{
  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
};
r = MultiplyDeBruijnBitPosition[((uint32_t)((v & -v) * 0x077CB531U)) >> 27];
将位向量转换为设置位的索引就是一个使用示例。 它比之前的手术需要多做一次手术 模数除法，但乘法可能更快。表达式 （v & -v）从 v 中提取最低有效位 1。常数 0x077CB531UL 是一个德布鲁因序列，它产生一个独特的模式 位到高 5 位的每个可能的位位置，它是 相乘。当没有设置位时，返回 0。 更多信息可以通过阅读论文找到 使用 de Bruijn 序列在计算机单词中索引 1 作者：Charles E. 莱瑟森、哈拉尔德·普罗科夫和基思·H·兰德尔。
2005 年 10 月 8 日， Andrew Shapira 建议我添加这个功能。2009 年 4 月 14 日，Dustin Spicuzza 让我将乘法的结果转换为 32 位类型，这样在使用 64 位整数编译时就可以正常工作。


通过浮点数转换向上舍入到 2 的下一个最高幂
unsigned int const v; // 将此 32 位值四舍五入为 2 的下一个最高幂
unsigned int r; // 将结果放在这里。（所以 v=3 -> r=4；v=8 -> r=8）if (v > 1)
{
浮点数 f = (浮点数)v;
无符号整数 const t = 1U << ((*(无符号整数 *)&f >> 23) - 0x7f);
r=t<<(t<v)；
}
别的
{
r＝1；
}
上面的代码使用了 8 个操作，但适用于所有 v <= (1<<31)。
快速而粗糙的版本，针对 1 < v < (1<<25) 的域：

浮点数 f = (浮点数)(v - 1);
r = 1U<< ((*(无符号整数*)(&f)>> 23) - 126);
虽然这个快速而粗糙的版本只使用了大约 6 个操作， 它大约比 下面的技术 （涉及 12 项操作）当 在 Athlon™ XP 2100+ CPU 上进行了基准测试。部分 CPU 的性能会略有下降。 但有了它就更好了。
2005 年 9 月 27 日，安迪·史密瑟斯 (Andi Smithers) 建议我加入一种强制转换为浮点数的技术，以找到数字的 lg，然后将其向上舍入为 2 的幂。与此处的快速而粗糙的版本类似，由于尾数舍入，他的版本适用于小于 (1<<25) 的值，但它使用了多一个操作。


向上舍入到 2 的下一个最高幂
unsigned int v; // 计算 32 位 v 的下一个最高 2 的幂 v--;
v |= v >> 1;
v |= v >> 2;
v |= v >> 4;
v |= v >> 8;
v |= v >> 16;
v++；
经过 12 次运算，此代码计算出 32位整数。 结果可以用公式 1U << (lg(v - 1) + 1) 来表示。 请注意，在 v 为 0 的边缘情况下，它返回 0，这不是 2 的幂；你可以附加表达式 v += (v == 0) 来解决这个问题 如果这很重要的话。 使用公式和 使用查找表的对数底 2 方法， 但在某些情况下，查找表并不适用，所以上面的代码 可能是最好的。（在 Athlon™ XP 2100+ 上，我发现上面的左移 然后 OR 代码与使用单个 BSR 汇编语言一样快 指令，该指令反向扫描以找到最高设置位。） 它的工作原理是将最高设置位复制到所有较低的 位，然后加一，这样就产生了进位，从而设置了所有较低的 位设置为 0，最高位之后一位设置为 1。如果原始 数字是 2 的幂，那么减量将使它减少 1，所以 我们将其四舍五入为相同的原始值。
您也可以使用查找表查找 floor(lg(v))，然后计算 1<<(1+floor(lg(v)))，仅用 8 或 9 次运算来计算 2 的下一个更高次幂；Atul Divekar 于 2010 年 9 月 5 日建议我提到这一点。

由 Sean Anderson 于 2001 年 9 月 14 日设计。 皮特·哈特 指向我 1997 年 2 月，他和威廉·刘易斯 (William Lewis) 在新闻组上发表了几篇文章 ，他们在文章中提出了相同的算法。


以显而易见的方式交织位
unsigned short x; // 交织 x 和 y 的位，以便所有
unsigned short y; // x 的位在偶数位置，y 在奇数位置；
unsigned int z = 0; // z 获取结果 Morton Number.for (int i = 0; i < sizeof(x) * CHAR_BIT; i++) // 展开以获得更快的速度...
{
z |= (x & 1U << i) << i | (y & 1U << i) << (i + 1);
}
交错位（又称 Morton 数）对于线性化二维整数很有用 坐标，因此 x 和 y 被组合成一个数字，可以 很容易比较，并且具有一个数字通常接近的属性 如果它们的 x 和 y 值接近，则为另一个。

通过查表来交织位
静态 const 无符号短整型 MortonTable256[256] =
{
0x0000, 0x0001, 0x0004, 0x0005, 0x0010, 0x0011, 0x0014, 0x0015,
0x0040, 0x0041, 0x0044, 0x0045, 0x0050, 0x0051, 0x0054, 0x0055,
0x0100, 0x0101, 0x0104, 0x0105, 0x0110, 0x0111, 0x0114, 0x0115,
0x0140, 0x0141, 0x0144, 0x0145, 0x0150, 0x0151, 0x0154, 0x0155,
0x0400, 0x0401, 0x0404, 0x0405, 0x0410, 0x0411, 0x0414, 0x0415,
0x0440, 0x0441, 0x0444, 0x0445, 0x0450, 0x0451, 0x0454, 0x0455,
0x0500, 0x0501, 0x0504, 0x0505, 0x0510, 0x0511, 0x0514, 0x0515,
0x0540, 0x0541, 0x0544, 0x0545, 0x0550, 0x0551, 0x0554, 0x0555,
0x1000, 0x1001, 0x1004, 0x1005, 0x1010, 0x1011, 0x1014, 0x1015,
0x1040, 0x1041, 0x1044, 0x1045, 0x1050, 0x1051, 0x1054, 0x1055,
0x1100, 0x1101, 0x1104, 0x1105, 0x1110, 0x1111, 0x1114, 0x1115,
0x1140, 0x1141, 0x1144, 0x1145, 0x1150, 0x1151, 0x1154, 0x1155,
0x1400, 0x1401, 0x1404, 0x1405, 0x1410, 0x1411, 0x1414, 0x1415,
0x1440, 0x1441, 0x1444, 0x1445, 0x1450, 0x1451, 0x1454, 0x1455,
0x1500, 0x1501, 0x1504, 0x1505, 0x1510, 0x1511, 0x1514, 0x1515,
0x1540, 0x1541, 0x1544, 0x1545, 0x1550, 0x1551, 0x1554, 0x1555,
0x4000, 0x4001, 0x4004, 0x4005, 0x4010, 0x4011, 0x4014, 0x4015,
0x4040, 0x4041, 0x4044, 0x4045, 0x4050, 0x4051, 0x4054, 0x4055,
0x4100, 0x4101, 0x4104, 0x4105, 0x4110, 0x4111, 0x4114, 0x4115,
0x4140, 0x4141, 0x4144, 0x4145, 0x4150, 0x4151, 0x4154, 0x4155,
0x4400, 0x4401, 0x4404, 0x4405, 0x4410, 0x4411, 0x4414, 0x4415,
0x4440, 0x4441, 0x4444, 0x4445, 0x4450, 0x4451, 0x4454, 0x4455,
0x4500, 0x4501, 0x4504, 0x4505, 0x4510, 0x4511, 0x4514, 0x4515,
0x4540, 0x4541, 0x4544, 0x4545, 0x4550, 0x4551, 0x4554, 0x4555,
0x5000, 0x5001, 0x5004, 0x5005, 0x5010, 0x5011, 0x5014, 0x5015,
0x5040, 0x5041, 0x5044, 0x5045, 0x5050, 0x5051, 0x5054, 0x5055,
0x5100, 0x5101, 0x5104, 0x5105, 0x5110, 0x5111, 0x5114, 0x5115,
0x5140, 0x5141, 0x5144, 0x5145, 0x5150, 0x5151, 0x5154, 0x5155,
0x5400, 0x5401, 0x5404, 0x5405, 0x5410, 0x5411, 0x5414, 0x5415,
0x5440, 0x5441, 0x5444, 0x5445, 0x5450, 0x5451, 0x5454, 0x5455,
0x5500, 0x5501, 0x5504, 0x5505, 0x5510, 0x5511, 0x5514, 0x5515,
0x5540, 0x5541, 0x5544, 0x5545, 0x5550, 0x5551, 0x5554, 0x5555
};unsigned short x; // 交织 x 和 y 的位，以便所有
unsigned short y; // x 的位在偶数位置，y 在奇数位置；
unsigned int z; // z 获取结果 32 位 Morton 数。z = MortonTable256[y >> 8] << 17 |
MortonTable256[x >> 8] << 16 |
MortonTable256[y & 0xFF] << 1 |
MortonTable256[x & 0xFF];

为了提高速度，请使用带有以下值的附加表 MortonTable256 预左移一位。第二个表 然后可以用于 y 查找，从而减少 操作数增加了两次，但所需的内存却几乎增加了一倍。 扩展这个想法，可以使用四个表，其中两个 预移位 16 位到前两个数的左侧，这样我们就可以 总共只需要11次操作。
使用 64 位乘法进行交织位
在 11 次操作中，此版本对两个字节的位进行交织 （而不是像其他版本那样是短裤）， 但许多运算都是 64 位乘法 所以它并不适用于所有机器。输入参数 x 和 y 应小于 256。
unsigned char x; // 交错 x 和 y 的位（8 位），以便所有
unsigned char y; // x 的位在偶数位置，y 在奇数位置；
unsigned short z; // z 获取结果的 16 位 Morton 数。z = ((x * 0x0101010101010101ULL & 0x8040201008040201ULL) *
0x0102040810204081ULL>> 49) & 0x5555 |
（（y * 0x010101010101010101ULL & 0x8040201008040201ULL）*
0x0102040810204081ULL>> 48) & 0xAAAA;
Holger Bettag 受到启发，建议采用这种技术 2004 年 10 月 10 日，阅读了此处基于乘法的位反转之后。

通过二进制幻数交织位
静态 const 无符号整数 B[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF};
static const unsigned int S[] = {1, 2, 4, 8};unsigned int x; // 将 x 和 y 的低 16 位交织，因此 x 的位
unsigned int y; // 位于偶数位置且 y 的位位于奇数位置；
unsigned int z; // z 获取结果 32 位 Morton 数。
// x 和 y 最初必须小于 65536。x = (x | (x << S[3])) & B[3];
x = (x | (x << S[2])) & B[2];
x = (x | (x << S[1])) & B[1];
x = (x | (x << S[0])) & B[0];y = (y | (y << S[3])) & B[3];
y = (y | (y << S[2])) & B[2];
y = (y | (y << S[1])) & B[1];
y = (y | (y << S[0])) & B[0];z = x | (y << 1);
确定一个单词是否含有零字节
// 更少的操作：
unsigned int v; // 32 位字，检查其中是否有 8 位字节为 0
bool hasZeroByte = ~((((v & 0x7F7F7F7F) + 0x7F7F7F7F) | v) | 0x7F7F7F7F);
上面的代码在进行快速字符串复制时可能会有用，其中一个单词 一次复制；它使用 5 个操作。 另一方面，以明显的方式测试空字节（如下） 至少有 7 次操作（以最节省的方式计算），最多有 12 次操作。
// 更多操作：
bool hasNoZeroByte = ((v & 0xff) && (v & 0xff00) && (v & 0xff0000) && (v & 0xff000000))
// 或者：
无符号字符*p = (无符号字符*)&v;
bool hasNoZeroByte = *p && *(p + 1) && *(p + 2) && *(p + 3);
本节开头的代码（标记为“更少的操作”） 其工作原理是首先将字中 4 个字节的高位清零。 随后，它添加一个数字，该数字将导致溢出 如果任何低位最初被设置，则为字节的高位。 接下来将原始字的高位与这些值进行“或”运算； 因此，当且仅当字节中的任何位被设置时，才设置该字节的高位。 最后，我们通过与以下项进行或运算来确定这些高位中是否有零： 除高位外，其他位置均为 1，并将结果反转。 扩展到 64 位很简单；只需增加常量即可 0x7F7F7F7F7F7F7F7F。
为了进一步改进，可以执行一个仅需 4 次操作的快速预测试来确定该字是否可能包含零字节。如果高字节为 0x80，该测试也会返回 true，因此偶尔会出现误报，但上述速度较慢且更可靠的版本可用于候选，从而在输出正确的情况下整体提高速度。


bool hasZeroByte = ((v + 0x7efefeff) ^ ~v) & 0x81010100;
if (hasZeroByte) // 或者高字节可能只有 0x80
{
hasZeroByte = ~((((v & 0x7F7F7F7F) + 0x7F7F7F7F) | v) | 0x7F7F7F7F);
}
还有一种更快的方法——使用 hasless (v, 1)，定义如下；它只需 4 次操作，并且无需后续验证。它简化为

#define haszero(v) (((v) - 0x01010101UL) & ~(v) & 0x80808080UL)
子表达式 (v - 0x01010101UL) 计算任意 每当 v 中的对应字节为零或大于 0x80 时，字节。 子表达式 ~v & 0x80808080UL 计算为字节中的高位集，其中 v 的字节没有其高位 位设置（因此字节小于 0x80）。最后，通过对这两个 子表达式的结果为高位设置，其中 v 中的字节 为零，因为由于大于 0x80 的值而设置了高位 第一个子表达式被第二个子表达式掩盖。
Paul Messmer 于 2004 年 10 月 2 日建议进行快速预测试改进。Juha Järvi 后来于 2005 年 4 月 6 日建议使用 hasless(v, 1) ，他在 Paul Hsieh 的 Assembly Lab 上找到了这个建议；此前它是由 Alan Mycroft 于 1987 年 4 月 27 日在一个新闻组帖子中写的。


确定一个单词是否有一个等于 n 的字节
我们可能想知道一个字中是否有一个字节具有特定的值。为此， 我们可以将要测试的值与已填充的单词进行异或 我们感兴趣的字节值。因为对一个值进行异或运算 结果为零字节，否则为非零，我们可以将结果传递给 haszero 。
#定义 hasvalue(x,n) \
（haszero（（x）^（~0UL/255 *（n））））
2009 年 12 月 13 日，Stephen M Bennet 在阅读了 haszero 的条目后提出了这个建议。


确定一个单词是否有小于 n 的字节
测试字 x 是否包含值为 < n 的无符号字节。 具体来说，对于 n=1，它可以通过检查一个来找到 0 字节 一次获取长字节，或者先将 x 与掩码进行异或运算，获取任意字节。 当 n 为常数时，使用 4 个算术/逻辑运算。
要求：x>=0；0<=n<=128

#define hasless(x,n) (((x)-~0UL/255*(n))&~(x)&~0UL/255*128)
要计算 7 次操作中 x 中小于 n 的字节数，请使用
#定义无数（x，n）\
(((~0UL/255*(127+(n))-((x)&~0UL/255*127))&~(x)&~0UL/255*128)/128%255)
Juha Järvi 于 2005 年 4 月 6 日将这个巧妙的技术发送给了我。 countless 宏是由 Sean Anderson 于 2005 年 4 月 10 日添加的，灵感来自 Juha 的 countmore ，如下所示。


确定一个单词是否有大于 n 的字节
测试字 x 是否包含值为 > n 的无符号字节。 当 n 为常数时，使用 3 个算术/逻辑运算。
要求：x>=0；0<=n<=127

#define hasmore(x,n) (((x)+~0UL/255*(127-(n))|(x))&~0UL/255*128)
要计算 6 次操作中 x 中大于 n 的字节数，请使用：
#定义 countmore(x,n) \
(((((x)&~0UL/255*127)+~0UL/255*(127-(n))|(x))&~0UL/255*128)/128%255)
宏 hasmore 是由 Juha Järvi 于 2005 年 4 月 6 日建议的，并且他于 2005 年 4 月 8 日添加了 countmore 。


确定一个单词是否有介于 m 和 n 之间的字节
当 m < n 时，此技术测试单词 x 是否包含 无符号字节值，例如 m < 值 < n。 当 n 和 m 为常数时，它使用 7 个算术/逻辑运算。
注意：等于 n 的字节可能会被 likelyhasbetween 报告为误报，因此如果需要特定结果，则应按字符进行检查。

要求：x>=0；0<=m<=127；0<=n<=128


#定义 likelyhasbetween(x,m,n) \
((((x)-~0UL/255*(n))&~(x)&((x)&~0UL/255*127)+~0UL/255*(127-(m)))&~0UL/255*128)
这项技术适合快速预测试。 需要再进行一次运算（对于常数 m 和 n 总共需要 8 次运算） 但提供的确切答案是：
#define hasbetween(x,m,n) \
((~0UL/255*(127+(n))-((x)&~0UL/255*127)&~(x)&((x)&~0UL/255*127)+~0UL/255*(127-(m)))&~0UL/255*128)
计算 x 中介于 m 和 n 之间（不包括 m 和 n）的字节数 在 10 次操作中，使用：
#define count Between(x,m,n) (has Between(x,m,n)/128%255)
Juha Järvi 于 2005 年 4 月 6 日提出了 likelyhasbetween 。此后，Sean Anderson 创建了 hasbetween 和 countbetween 于 2005 年 4 月 10 日。


按字典顺序计算下一个位排列
假设我们有一个整数中 N 位设置为 1 的模式，并且我们希望 从字典顺序来看，N 1 位的下一个排列。 例如，如果 N 为 3，且位模式为 00010011，则接下来的模式 将是 00010101, 00010110, 00011001,00011010, 00011100, 00100011, 等等。以下是计算下一个排列的快速方法。
unsigned int v; // 当前位的排列
unsigned int w; // 位的下一个排列 unsigned int t = v | (v - 1); // t 将 v 的最低有效 0 位设置为 1
// 接下来将要更改的最高有效位设置为 1，
// 将最低有效位设置为 0，并添加必要的 1 位。
w = (t + 1) | (((~t & -~t) - 1) >> (__builtin_ctz(v) + 1));
__builtin_ctz(v) GNU C 编译器针对 x86 CPU 的内部函数返回 尾随零的数量。如果您使用的是 Microsoft x86 编译器， 内在函数是 _BitScanForward。它们都发出 bsf 指令，但是 其他架构可能也有类似的方案。如果没有，那么 考虑使用其中一种方法来计算连续的零位 前面提到过。
这是另一个版本，由于其除法运算符，它的速度往往较慢，但它不需要计算尾随零。

无符号整数 t = (v | (v - 1)) + 1;
w = t | ((((t & -t) / (v & -v)) >> 1) - 1);
感谢阿根廷的 Dario Sneidermanis 于 2009 年 11 月 28 日提供此信息。

提供白俄罗斯语翻译 （由 Webhostingrating 提供）。

